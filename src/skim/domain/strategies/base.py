"""Base strategy interface and event types"""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any


class EventType(Enum):
    """Types of events that can trigger strategy actions."""

    SCAN = "scan"
    TRADE = "trade"
    MANAGE = "manage"
    ALERT = "alert"
    TRACK_RANGES = "track_ranges"
    HEALTH_CHECK = "health_check"
    SETUP = "setup"
    CUSTOM = "custom"


@dataclass
class Event:
    """Event that triggers strategy actions.

    Attributes:
        type: Type of event
        payload: Event-specific data
        timestamp: When the event was created
    """

    type: EventType
    payload: dict[str, Any] | None = None
    timestamp: datetime | None = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


@dataclass
class Signal:
    """Signal generated by a strategy.

    Attributes:
        type: Type of signal
        ticker: Target ticker symbol
        action: Recommended action (BUY, SELL, etc.)
        price: Target price
        quantity: Position quantity
        metadata: Additional signal data
    """

    ticker: str
    action: str
    price: float | None = None
    quantity: int | None = None
    metadata: dict[str, Any] | None = None


class Strategy(ABC):
    """Base trading strategy interface

    All trading strategies must implement this interface.
    A strategy is responsible for:
    - Signal generation (entry/exit logic)
    - Candidate identification and scanning
    - Position management
    - Strategy-specific lifecycle management
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy name identifier"""

    @abstractmethod
    async def scan(self) -> int:
        """Scan for candidates

        Returns:
            Number of candidates found/created
        """

    @abstractmethod
    async def trade(self) -> int:
        """Execute trade entries

        Returns:
            Number of trades executed
        """

    @abstractmethod
    async def manage(self) -> int:
        """Manage open positions

        Returns:
            Number of positions managed/exited
        """

    async def on_event(self, event: Event) -> list[Signal]:
        """Handle an event and return signals.

        Default implementation dispatches to specific methods.
        Override this for event-driven strategies.

        Args:
            event: Event to handle

        Returns:
            List of signals generated
        """
        if event.type == EventType.SCAN:
            count = await self.scan()
            return [
                Signal(
                    ticker="", action="scan_complete", metadata={"count": count}
                )
            ]
        elif event.type == EventType.TRADE:
            count = await self.trade()
            return [
                Signal(
                    ticker="",
                    action="trade_complete",
                    metadata={"count": count},
                )
            ]
        elif event.type == EventType.MANAGE:
            count = await self.manage()
            return [
                Signal(
                    ticker="",
                    action="manage_complete",
                    metadata={"count": count},
                )
            ]
        elif event.type == EventType.ALERT:
            count = await self.alert()
            return [
                Signal(
                    ticker="",
                    action="alert_complete",
                    metadata={"count": count},
                )
            ]
        elif event.type == EventType.TRACK_RANGES:
            count = await self.track_ranges()
            return [
                Signal(
                    ticker="",
                    action="track_complete",
                    metadata={"count": count},
                )
            ]
        elif event.type == EventType.HEALTH_CHECK:
            healthy = await self.health_check()
            return [
                Signal(
                    ticker="",
                    action="health_check",
                    metadata={"healthy": healthy},
                )
            ]
        elif event.type == EventType.SETUP:
            await self.setup()
            return [Signal(ticker="", action="setup_complete")]
        return []

    async def health_check(self) -> bool:
        """Optional health check

        Returns:
            True if strategy is healthy
        """
        return True

    async def alert(self) -> int:
        """Send notifications for tradeable candidates

        Strategies can override this to send Discord alerts.
        Called after track_ranges completes and before trade execution.

        Returns:
            Number of candidates alerted
        """
        return 0

    async def track_ranges(self) -> int:
        """Track opening ranges for candidates

        Strategies can override this to track opening ranges.
        Some strategies (like ORH breakout) need to track opening ranges
        before executing trades.

        Returns:
            Number of candidates updated with opening ranges
        """
        return 0

    async def setup(self) -> None:  # noqa: B027
        """Setup strategy before scanning

        Strategies can override this for initialization tasks.
        Called once before the first scan.

        Note: This method is intentionally not abstract to allow strategies
        to optionally implement setup logic without requiring the decorator.
        """
        pass
